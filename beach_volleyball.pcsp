// Game states 
// TODO: team side change court every multiple seven points in sets 1 and 2, and every 5 points in set 3
//       A           B
// +-----+-----+-----+-----+
// |     |     ‖     |     |
// |  1  |  3  ‖  5  |  7  |
// |     |     ‖     |     |
// |-----|-----‖-----|-----|
// |     |     ‖     |     |
// |  2  |  4  ‖  6  |  8  |
// |     |     ‖     |     |
// +-----+-----+-----+-----+

enum{grid_one, grid_two, grid_three, grid_four, grid_five, grid_six, grid_seven, grid_eight, out_of_court};

// Game rules
#define team_A 1;
#define team_B 2;
#define na 0;
//for testing use lower points 
#define max_total_sets 3;
#define max_total_pts 21;
#define max_total_pts_last_set 15; 
#define winning_set_lead 0;
#define max_touch 3; // dig -> set -> spike (common sequence) to be used for full game
 
hvar team_A1_player_pos = grid_two;
hvar team_A2_player_pos = grid_one;
hvar team_B1_player_pos = grid_eight;
hvar team_B2_player_pos = grid_seven;
hvar ball_pos = 0;
hvar set_num = 1;
var team_A_set_score = 0;
var team_B_set_score = 0;
var team_A_game_score = 0;
var team_B_game_score = 0;
var turnToServe = na; 
var checkAPlayerServe = 1 // 1 means Team A player 1 serve, 0 means  Team A player 2 serve
var checkBPlayerServe = 1 // 1 means Team B player 1 serve, 0 means  Team B player 2 serve
var gameWon = na;

BeachVolleyBallGame = WhoServe1st; (TeamAServeNewSet [] TeamBServeNewSet);

WhoServe1st = []i:{team_A,team_B}@ TossCoin{turnToServe = i} -> Skip;
// Only used for first serve of the set, will use turnToServe = team A or B based on coin toss
TeamAServeNewSet = [gameWon == na && turnToServe == team_A]{if (checkAPlayerServe==1) {TeamAPlayer1Serve} else{TeamAPlayer2Serve}};
TeamBServeNewSet = [gameWon == na && turnToServe == team_B]{if (checkBPlayerServe==1) {TeamBPlayer1Serve} else{TeamBPlayer2Serve}};

TeamAPlayer1Serve = Team_A_has_ball{ball_pos = grid_one; team_A2_player_pos = grid_one; team_A1_player_pos = grid_two; team_B1_player_pos = grid_eight; team_B2_player_pos = grid_seven;} 
        -> Serve_A;
TeamAPlayer2Serve = Team_A_has_ball{ball_pos = grid_two; team_A2_player_pos = grid_one; team_A1_player_pos = grid_two; team_B1_player_pos = grid_eight; team_B2_player_pos = grid_seven;} 
        -> Serve_A;
TeamBPlayer1Serve = Team_B_has_ball{ball_pos = grid_seven; team_B2_player_pos = grid_seven; team_B1_player_pos = grid_eight; team_A1_player_pos = grid_two; team_A2_player_pos = grid_one;} 
        -> Serve_B;
TeamBPlayer2Serve = Team_B_has_ball{ball_pos = grid_seven; team_B2_player_pos = grid_seven; team_B1_player_pos = grid_eight; team_A1_player_pos = grid_two; team_A2_player_pos = grid_one;} 
        -> Serve_B;
TeamAServe = [gameWon == na]{if (checkAPlayerServe==1) {TeamAPlayer1Serve} else{TeamAPlayer2Serve}};
TeamBServe = [gameWon == na]{if (checkBPlayerServe==1) {TeamBPlayer1Serve} else{TeamBPlayer2Serve}};

#define team_A_win_game team_A_game_score == 2;
#define team_B_win_game team_B_game_score == 2;
#define team_A_win_set team_A_set_score >= team_B_set_score + winning_set_lead && 
	((set_num == max_total_sets && team_A_set_score >= max_total_pts_last_set) ||
	(team_A_set_score >= max_total_pts));
#define team_B_win_set team_B_set_score >= team_A_set_score + winning_set_lead && 
	((set_num == max_total_sets && team_B_set_score >= max_total_pts_last_set) ||
	(team_B_set_score >= max_total_pts));

// TODO: the logic who serves next, is it the friend or same person?
#define players_starting_position team_A1_player_pos == grid_two && team_A2_player_pos == grid_one && team_B1_player_pos == grid_eight && team_B2_player_pos == grid_seven;

// Full game todo: retoss coin again if third round instead of using the same team 
New_Set = updateGameScore{if (team_A_win_set) { team_A_game_score++; turnToServe == team_B; } else {team_B_game_score++; turnToServe == team_A; }}
	-> resetScore{team_A_set_score=0; team_B_set_score=0;}
	-> incrementSet{set_num++}
	-> checkForWin{if (team_A_win_game) { gameWon = team_A } else if (team_B_win_game) { gameWon = team_B } }
	-> checkTeamServeNext{if (turnToServe == team_A) {TeamAServeNewSet} else {TeamBServeNewSet}};

// TODO: Make all 4 players reposition themselves to starting grid for new point
// Can have some rules who is the one serving? (for full game)
Increment_Team_A_Set_Score = increment{team_A_set_score++;} -> swapPlayerBServer{if (checkAPlayerServe==1) {checkBPlayerServe=0;} else {checkBPlayerServe=1;}} -> if (team_A_win_set) {New_Set} else {TeamAServe};
Increment_Team_B_Set_Score = increment{team_B_set_score++;} -> swapPlayerAServer{if (checkBPlayerServe==1) {checkAPlayerServe=0;} else {checkAPlayerServe=1;}} -> if (team_B_win_set) {New_Set} else {TeamBServe};


Reset_ball_and_players(ball_reset_pos) = reset_ball_players{ ball_pos = ball_reset_pos; team_A1_player_pos == grid_two && team_A2_player_pos == grid_one && team_B1_player_pos == grid_eight && team_B2_player_pos == grid_seven;} -> Skip;
// TODO: can dig from back grid to any position in opposite court
// current assumption is starting position is 3 and 6 for serving
Serve_A = pcase {
    25: Serve_diagonal{ball_pos = grid_five} -> Dig_B
    25: Serve_straight{ball_pos = grid_six} -> Dig_B
    50: Fault{ball_pos = out_of_court} -> Increment_Team_B_Set_Score
};

Serve_B = pcase {
    25: Serve_diagonal{ball_pos = grid_three} -> Dig_A
    25: Serve_straight{ball_pos = grid_four} -> Dig_A
    50: Fault{ball_pos = out_of_court} -> Increment_Team_A_Set_Score
};

// We can dig to same court or different side of court for flexibility
// TODO: ball_pos can be grid 5-8
// Can you dig again after a dig?
// Can you dig directly straight to opponent court?
Dig_A = pcase {
    25: [ball_pos == grid_three || ball_pos == grid_four]Dig_opposite_court{if(ball_pos == grid_three) {team_A1_player_pos = ball_pos; ball_pos = grid_four;} 
    	else if (ball_pos == grid_four) {team_A1_player_pos = ball_pos; ball_pos = grid_three}}
    	-> Set_A
    25: [ball_pos == grid_three || ball_pos == grid_four]Dig_same_court{team_A1_player_pos = ball_pos;} 
    	-> Set_A
    50: Fault{ball_pos = out_of_court} -> Increment_Team_B_Set_Score
};

Dig_B = pcase {
    25: [ball_pos == grid_five || ball_pos == grid_six]Dig_opposite_court{if(ball_pos == grid_five) {team_B1_player_pos = ball_pos; ball_pos = grid_six;} 
    	else if (ball_pos == grid_six) {team_B1_player_pos = ball_pos; ball_pos = grid_five}}
    	-> Set_B
    25: [ball_pos == grid_five || ball_pos == grid_six]Dig_same_court{team_B1_player_pos = ball_pos;} 
    	-> Set_B
    50: Fault{ball_pos = out_of_court} -> Increment_Team_A_Set_Score
};

// TODO: can set to opposite or same grid (currently assume same grid)
Set_A = pcase {
	50: [ball_pos == grid_three || ball_pos == grid_four] Set_same_court{team_A1_player_pos = ball_pos;} -> Attack_A
    50: Fault{ball_pos = out_of_court} -> Increment_Team_B_Set_Score
};

Set_B = pcase {
    50: [ball_pos == grid_five || ball_pos == grid_six] Set_same_court{team_B1_player_pos = ball_pos;} -> Attack_B
    50: Fault{ball_pos = out_of_court} -> Increment_Team_A_Set_Score
};

// TODO: to expand with rollshot, cutshot etc
// Attack process is just for decision making for the attacker, no change in ball_pos or player position should be done here
Attack_A = pcase {
    100: Spike -> Spike_A
};

Attack_B = pcase {
    100: Spike -> Spike_B
};

// assumption: gets blocked directly infront instead of diagonal court (although the spike intended to be diagonal)
// if spike is not blocked, then the back opponent will dig (assume diagonal court for full game extensibility)
Spike_A = pcase {
    25: gets_blocked{if(ball_pos == grid_three) {team_A1_player_pos = ball_pos; ball_pos = grid_five;}
    		else if (ball_pos == grid_four) {team_A1_player_pos = ball_pos; ball_pos = grid_six;}} -> Block_B
    25: gets_digged{if (ball_pos == grid_three) {team_A1_player_pos = ball_pos; ball_pos = grid_six;}
    		else if (ball_pos == grid_four) {team_A1_player_pos = ball_pos; ball_pos = grid_five;}} -> Dig_B
    50: Fault{ball_pos = out_of_court} -> Increment_Team_B_Set_Score
};

Spike_B = pcase {
    25: gets_blocked{if(ball_pos == grid_five) {team_B1_player_pos = ball_pos; ball_pos = grid_three;}
    		else if (ball_pos == grid_six) {team_B1_player_pos = ball_pos; ball_pos = grid_four;}} -> Block_A
    25: gets_digged{if (ball_pos == grid_five) {team_B1_player_pos = ball_pos; ball_pos = grid_four;}
    		else if (ball_pos == grid_six) {team_B1_player_pos = ball_pos; ball_pos = grid_three;}} -> Dig_A
    50: Fault{ball_pos = out_of_court} -> Increment_Team_A_Set_Score
};

Block_A = pcase {
    50: block_straight{if (ball_pos == grid_three) {team_A1_player_pos = ball_pos; ball_pos = grid_five;}
    		else if (ball_pos == grid_four) {team_A1_player_pos = ball_pos; ball_pos = grid_six;}} -> Dig_B
    50: Fault{ball_pos = out_of_court} -> Increment_Team_B_Set_Score
};

Block_B = pcase {
    50: block_straight{if (ball_pos == grid_five) {team_B1_player_pos = ball_pos; ball_pos = grid_three;}
    		else if (ball_pos == grid_six) {team_B1_player_pos = ball_pos; ball_pos = grid_four;}} -> Dig_A
    50: Fault{ball_pos = out_of_court} -> Increment_Team_A_Set_Score
};

// should be close to 50-50 as points per match increase
#assert BeachVolleyBallGame reaches team_A_win_game with prob;
//#assert BeachVolleyBallGame reaches team_B_win_game with prob;
